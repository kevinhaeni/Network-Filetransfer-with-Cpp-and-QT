<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>netcomm: net::StreamListener Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">netcomm
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>net</b></li><li class="navelem"><a class="el" href="a00026.html">StreamListener</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="a00137.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">net::StreamListener Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Singleton reactor/dispatcher.  
 <a href="a00026.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00059_source.html">sample/net/StreamListener.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for net::StreamListener:</div>
<div class="dyncontent">
<div class="center"><img src="a00138.gif" border="0" usemap="#net_1_1_stream_listener_coll__map" alt="Collaboration graph"/></div>
<map name="net_1_1_stream_listener_coll__map" id="net_1_1_stream_listener_coll__map">
<area shape="rect" id="node2" href="a00032.html" title="Thread mutex implemented by means of a critical section. " alt="" coords="12,83,135,109"/><area shape="rect" id="node3" href="a00013.html" title="Base interface for synchronization objects. " alt="" coords="14,5,132,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15e64555f86c587f88ead069d1ea24d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15e64555f86c587f88ead069d1ea24d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a15e64555f86c587f88ead069d1ea24d1">addDelegate</a> (<a class="el" href="a00022.html">TStreamPtr</a> stream, <a class="el" href="a00012.html">IStreamListenerDelegate</a> *delegate_)</td></tr>
<tr class="memdesc:a15e64555f86c587f88ead069d1ea24d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds delegate_ as an observer of stream's incoming data events. <br/></td></tr>
<tr class="separator:a15e64555f86c587f88ead069d1ea24d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f3ada1fcc33d43ff7ce3a34a6c5d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d">run</a> ()</td></tr>
<tr class="memdesc:a81f3ada1fcc33d43ff7ce3a34a6c5d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs listening loop.  <a href="#a81f3ada1fcc33d43ff7ce3a34a6c5d0d">More...</a><br/></td></tr>
<tr class="separator:a81f3ada1fcc33d43ff7ce3a34a6c5d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c578c5e3aab1aa1437e4418b883e5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a82c578c5e3aab1aa1437e4418b883e5c">cancelRun</a> ()</td></tr>
<tr class="memdesc:a82c578c5e3aab1aa1437e4418b883e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to request <a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d" title="Runs listening loop. ">run()</a> to stop listening to events.  <a href="#a82c578c5e3aab1aa1437e4418b883e5c">More...</a><br/></td></tr>
<tr class="separator:a82c578c5e3aab1aa1437e4418b883e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356d8d7aa78dbfc05c7e6c4b2c2caca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ae356d8d7aa78dbfc05c7e6c4b2c2caca">joinRun</a> ()</td></tr>
<tr class="memdesc:ae356d8d7aa78dbfc05c7e6c4b2c2caca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the stop request to complete.  <a href="#ae356d8d7aa78dbfc05c7e6c4b2c2caca">More...</a><br/></td></tr>
<tr class="separator:ae356d8d7aa78dbfc05c7e6c4b2c2caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9bb428df95eec9c06e188352d59fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ada9bb428df95eec9c06e188352d59fd8">writeStream</a> (::net::IStream::TId stream, const unsigned char *buf, size_t count)</td></tr>
<tr class="memdesc:ada9bb428df95eec9c06e188352d59fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should be used when writing to watched stream instead of <a class="el" href="a00011.html#aed1f4676e9d6d11b65df0b0a4afa40e9" title="Implementation is expected to write() to a stream synchroniosly, but this is not mandatory. ">IStream::write()</a> in order to let the <a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> instance handle stream errors.  <a href="#ada9bb428df95eec9c06e188352d59fd8">More...</a><br/></td></tr>
<tr class="separator:ada9bb428df95eec9c06e188352d59fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e4812d23a9bd62393c5ba6dc1239ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0e4812d23a9bd62393c5ba6dc1239ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ac0e4812d23a9bd62393c5ba6dc1239ea">closeStream</a> (::net::IStream::TId streamId, const std::string &amp;errorDescription)</td></tr>
<tr class="memdesc:ac0e4812d23a9bd62393c5ba6dc1239ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly closes specified stream in case some higher level error occurs. <br/></td></tr>
<tr class="separator:ac0e4812d23a9bd62393c5ba6dc1239ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e64555f86c587f88ead069d1ea24d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15e64555f86c587f88ead069d1ea24d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a15e64555f86c587f88ead069d1ea24d1">addDelegate</a> (<a class="el" href="a00022.html">TStreamPtr</a> stream, <a class="el" href="a00012.html">IStreamListenerDelegate</a> *delegate_)</td></tr>
<tr class="memdesc:a15e64555f86c587f88ead069d1ea24d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds delegate_ as an observer of stream's incoming data events. <br/></td></tr>
<tr class="separator:a15e64555f86c587f88ead069d1ea24d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f3ada1fcc33d43ff7ce3a34a6c5d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d">run</a> ()</td></tr>
<tr class="memdesc:a81f3ada1fcc33d43ff7ce3a34a6c5d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs listening loop.  <a href="#a81f3ada1fcc33d43ff7ce3a34a6c5d0d">More...</a><br/></td></tr>
<tr class="separator:a81f3ada1fcc33d43ff7ce3a34a6c5d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c578c5e3aab1aa1437e4418b883e5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a82c578c5e3aab1aa1437e4418b883e5c">cancelRun</a> ()</td></tr>
<tr class="memdesc:a82c578c5e3aab1aa1437e4418b883e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to request <a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d" title="Runs listening loop. ">run()</a> to stop listening to events.  <a href="#a82c578c5e3aab1aa1437e4418b883e5c">More...</a><br/></td></tr>
<tr class="separator:a82c578c5e3aab1aa1437e4418b883e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356d8d7aa78dbfc05c7e6c4b2c2caca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ae356d8d7aa78dbfc05c7e6c4b2c2caca">joinRun</a> ()</td></tr>
<tr class="memdesc:ae356d8d7aa78dbfc05c7e6c4b2c2caca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the stop request to complete.  <a href="#ae356d8d7aa78dbfc05c7e6c4b2c2caca">More...</a><br/></td></tr>
<tr class="separator:ae356d8d7aa78dbfc05c7e6c4b2c2caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9bb428df95eec9c06e188352d59fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ada9bb428df95eec9c06e188352d59fd8">writeStream</a> (::net::IStream::TId stream, const unsigned char *buf, size_t count)</td></tr>
<tr class="memdesc:ada9bb428df95eec9c06e188352d59fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should be used when writing to watched stream instead of <a class="el" href="a00011.html#aed1f4676e9d6d11b65df0b0a4afa40e9" title="Implementation is expected to write() to a stream synchroniosly, but this is not mandatory. ">IStream::write()</a> in order to let the <a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> instance handle stream errors.  <a href="#ada9bb428df95eec9c06e188352d59fd8">More...</a><br/></td></tr>
<tr class="separator:ada9bb428df95eec9c06e188352d59fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e4812d23a9bd62393c5ba6dc1239ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0e4812d23a9bd62393c5ba6dc1239ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ac0e4812d23a9bd62393c5ba6dc1239ea">closeStream</a> (::net::IStream::TId streamId, const std::string &amp;errorDescription)</td></tr>
<tr class="memdesc:ac0e4812d23a9bd62393c5ba6dc1239ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly closes specified stream in case some higher level error occurs. <br/></td></tr>
<tr class="separator:ac0e4812d23a9bd62393c5ba6dc1239ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1620df5889914d5037e07be1c28a10cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1620df5889914d5037e07be1c28a10cf"></a>
static <a class="el" href="a00026.html">StreamListener</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a1620df5889914d5037e07be1c28a10cf">instance</a> ()</td></tr>
<tr class="memdesc:a1620df5889914d5037e07be1c28a10cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to access global singleton instance. <br/></td></tr>
<tr class="separator:a1620df5889914d5037e07be1c28a10cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806dbdf090f388e6c746c502375b2335"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a806dbdf090f388e6c746c502375b2335"></a>
static <a class="el" href="a00026.html">StreamListener</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a806dbdf090f388e6c746c502375b2335">instance</a> ()</td></tr>
<tr class="memdesc:a806dbdf090f388e6c746c502375b2335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to access global singleton instance. <br/></td></tr>
<tr class="separator:a806dbdf090f388e6c746c502375b2335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ac2a66911e4b791bf75b22a412cb51d5c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>LISTENER_STOPPED</b> = 0, 
<b>LISTENER_RUNNING</b>, 
<b>LISTENER_STOPPING</b>
 }</td></tr>
<tr class="memdesc:ac2a66911e4b791bf75b22a412cb51d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> internal state. <br/></td></tr>
<tr class="separator:ac2a66911e4b791bf75b22a412cb51d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b42789f75f17d0bcbb803d0f4139275"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>LISTENER_STOPPED</b> = 0, 
<b>LISTENER_RUNNING</b>, 
<b>LISTENER_STOPPING</b>
 }</td></tr>
<tr class="memdesc:a4b42789f75f17d0bcbb803d0f4139275"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> internal state. <br/></td></tr>
<tr class="separator:a4b42789f75f17d0bcbb803d0f4139275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fca2227380c1fc79ca1312dd67e444"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2fca2227380c1fc79ca1312dd67e444"></a>
typedef std::map<br class="typebreak"/>
&lt; ::net::IStream::TId, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TStreamsBusy</b></td></tr>
<tr class="separator:ab2fca2227380c1fc79ca1312dd67e444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71426f3c6f0409354eed2b48b19407f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad71426f3c6f0409354eed2b48b19407f"></a>
typedef std::vector&lt; HANDLE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>THandles</b></td></tr>
<tr class="separator:ad71426f3c6f0409354eed2b48b19407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0658da8241b1467d774f4456f90c6bf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0658da8241b1467d774f4456f90c6bf8"></a>
typedef std::map<br class="typebreak"/>
&lt; ::net::IStream::TId, <br class="typebreak"/>
<a class="el" href="a00022.html">TStreamPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TStreams</b></td></tr>
<tr class="separator:a0658da8241b1467d774f4456f90c6bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef7fe9ec156415b6838ea075926c1ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef7fe9ec156415b6838ea075926c1ed"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00012.html">IStreamListenerDelegate</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TDelegates</b></td></tr>
<tr class="separator:abef7fe9ec156415b6838ea075926c1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970130002395da9bd39ff50bb4c9a68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a970130002395da9bd39ff50bb4c9a68e"></a>
typedef std::map<br class="typebreak"/>
&lt; ::net::IStream::TId, <br class="typebreak"/>
TDelegates &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TStreamDelegates</b></td></tr>
<tr class="separator:a970130002395da9bd39ff50bb4c9a68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fca2227380c1fc79ca1312dd67e444"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2fca2227380c1fc79ca1312dd67e444"></a>
typedef std::map<br class="typebreak"/>
&lt; ::net::IStream::TId, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TStreamsBusy</b></td></tr>
<tr class="separator:ab2fca2227380c1fc79ca1312dd67e444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71426f3c6f0409354eed2b48b19407f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad71426f3c6f0409354eed2b48b19407f"></a>
typedef std::vector&lt; HANDLE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>THandles</b></td></tr>
<tr class="separator:ad71426f3c6f0409354eed2b48b19407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0658da8241b1467d774f4456f90c6bf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0658da8241b1467d774f4456f90c6bf8"></a>
typedef std::map<br class="typebreak"/>
&lt; ::net::IStream::TId, <br class="typebreak"/>
<a class="el" href="a00022.html">TStreamPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TStreams</b></td></tr>
<tr class="separator:a0658da8241b1467d774f4456f90c6bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef7fe9ec156415b6838ea075926c1ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef7fe9ec156415b6838ea075926c1ed"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00012.html">IStreamListenerDelegate</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TDelegates</b></td></tr>
<tr class="separator:abef7fe9ec156415b6838ea075926c1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970130002395da9bd39ff50bb4c9a68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a970130002395da9bd39ff50bb4c9a68e"></a>
typedef std::map<br class="typebreak"/>
&lt; ::net::IStream::TId, <br class="typebreak"/>
TDelegates &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TStreamDelegates</b></td></tr>
<tr class="separator:a970130002395da9bd39ff50bb4c9a68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3f1dca70a4c41de0d44dafbdaa2aeef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f1dca70a4c41de0d44dafbdaa2aeef2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a3f1dca70a4c41de0d44dafbdaa2aeef2">StreamListener</a> ()</td></tr>
<tr class="memdesc:a3f1dca70a4c41de0d44dafbdaa2aeef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation is forbidden. <br/></td></tr>
<tr class="separator:a3f1dca70a4c41de0d44dafbdaa2aeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6d5a8d9419b2879ecf3db03c8a9af9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d6d5a8d9419b2879ecf3db03c8a9af9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a7d6d5a8d9419b2879ecf3db03c8a9af9">spawnWorkerThread</a> ()</td></tr>
<tr class="memdesc:a7d6d5a8d9419b2879ecf3db03c8a9af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a worker thread. Must be executed under a sync. <br/></td></tr>
<tr class="separator:a7d6d5a8d9419b2879ecf3db03c8a9af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9ca9b5425e6abd29dd9838080d0209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9ca9b5425e6abd29dd9838080d0209"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a7c9ca9b5425e6abd29dd9838080d0209">listenStreams</a> ()</td></tr>
<tr class="memdesc:a7c9ca9b5425e6abd29dd9838080d0209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker routine, runs on multiple threads. <br/></td></tr>
<tr class="separator:a7c9ca9b5425e6abd29dd9838080d0209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c110f176068877f399ac021befa1d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a0c110f176068877f399ac021befa1d5a">streamDied</a> (::net::IStream::TId, const std::string &amp;errorDescription)</td></tr>
<tr class="memdesc:a0c110f176068877f399ac021befa1d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must NOT be executed under a lock.  <a href="#a0c110f176068877f399ac021befa1d5a">More...</a><br/></td></tr>
<tr class="separator:a0c110f176068877f399ac021befa1d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae654311b6c5bbe94a423047f28a122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00022.html">TStreamPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a4ae654311b6c5bbe94a423047f28a122">getNextStream</a> (TDelegates &amp;delegates, bool &amp;indexReset)</td></tr>
<tr class="memdesc:a4ae654311b6c5bbe94a423047f28a122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be executed under a lock.  <a href="#a4ae654311b6c5bbe94a423047f28a122">More...</a><br/></td></tr>
<tr class="separator:a4ae654311b6c5bbe94a423047f28a122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d6404f2beedb236dc1ded79df1e4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00022.html">TStreamPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#aa8d6404f2beedb236dc1ded79df1e4ae">getStreamById</a> (::net::IStream::TId streamId) const </td></tr>
<tr class="memdesc:aa8d6404f2beedb236dc1ded79df1e4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be executed under a lock.  <a href="#aa8d6404f2beedb236dc1ded79df1e4ae">More...</a><br/></td></tr>
<tr class="separator:aa8d6404f2beedb236dc1ded79df1e4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1dca70a4c41de0d44dafbdaa2aeef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f1dca70a4c41de0d44dafbdaa2aeef2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a3f1dca70a4c41de0d44dafbdaa2aeef2">StreamListener</a> ()</td></tr>
<tr class="memdesc:a3f1dca70a4c41de0d44dafbdaa2aeef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation is forbidden. <br/></td></tr>
<tr class="separator:a3f1dca70a4c41de0d44dafbdaa2aeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6d5a8d9419b2879ecf3db03c8a9af9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d6d5a8d9419b2879ecf3db03c8a9af9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a7d6d5a8d9419b2879ecf3db03c8a9af9">spawnWorkerThread</a> ()</td></tr>
<tr class="memdesc:a7d6d5a8d9419b2879ecf3db03c8a9af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a worker thread. Must be executed under a sync. <br/></td></tr>
<tr class="separator:a7d6d5a8d9419b2879ecf3db03c8a9af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9ca9b5425e6abd29dd9838080d0209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9ca9b5425e6abd29dd9838080d0209"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a7c9ca9b5425e6abd29dd9838080d0209">listenStreams</a> ()</td></tr>
<tr class="memdesc:a7c9ca9b5425e6abd29dd9838080d0209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker routine, runs on multiple threads. <br/></td></tr>
<tr class="separator:a7c9ca9b5425e6abd29dd9838080d0209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c110f176068877f399ac021befa1d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a0c110f176068877f399ac021befa1d5a">streamDied</a> (::net::IStream::TId, const std::string &amp;errorDescription)</td></tr>
<tr class="memdesc:a0c110f176068877f399ac021befa1d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must NOT be executed under a lock.  <a href="#a0c110f176068877f399ac021befa1d5a">More...</a><br/></td></tr>
<tr class="separator:a0c110f176068877f399ac021befa1d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae654311b6c5bbe94a423047f28a122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00022.html">TStreamPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a4ae654311b6c5bbe94a423047f28a122">getNextStream</a> (TDelegates &amp;delegates, bool &amp;indexReset)</td></tr>
<tr class="memdesc:a4ae654311b6c5bbe94a423047f28a122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be executed under a lock.  <a href="#a4ae654311b6c5bbe94a423047f28a122">More...</a><br/></td></tr>
<tr class="separator:a4ae654311b6c5bbe94a423047f28a122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d6404f2beedb236dc1ded79df1e4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00022.html">TStreamPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#aa8d6404f2beedb236dc1ded79df1e4ae">getStreamById</a> (::net::IStream::TId streamId) const </td></tr>
<tr class="memdesc:aa8d6404f2beedb236dc1ded79df1e4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be executed under a lock.  <a href="#aa8d6404f2beedb236dc1ded79df1e4ae">More...</a><br/></td></tr>
<tr class="separator:aa8d6404f2beedb236dc1ded79df1e4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ad571fc80e619e203cc8319e24561b5a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad571fc80e619e203cc8319e24561b5a0"></a>
static DWORD WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ad571fc80e619e203cc8319e24561b5a0">workerThreadFunc</a> (LPVOID param)</td></tr>
<tr class="memdesc:ad571fc80e619e203cc8319e24561b5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread start routine. <br/></td></tr>
<tr class="separator:ad571fc80e619e203cc8319e24561b5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e8a9e474ef241af7da6e0634e9c663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2e8a9e474ef241af7da6e0634e9c663"></a>
static DWORD WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#af2e8a9e474ef241af7da6e0634e9c663">workerThreadFunc</a> (LPVOID param)</td></tr>
<tr class="memdesc:af2e8a9e474ef241af7da6e0634e9c663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread start routine. <br/></td></tr>
<tr class="separator:af2e8a9e474ef241af7da6e0634e9c663"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a292a818a35e3df4fae19cd805926197d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a292a818a35e3df4fae19cd805926197d"></a>
enum net::StreamListener:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a292a818a35e3df4fae19cd805926197d">m_state</a></td></tr>
<tr class="memdesc:a292a818a35e3df4fae19cd805926197d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> internal state. <br/></td></tr>
<tr class="separator:a292a818a35e3df4fae19cd805926197d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dde7662180cc01e4d16df105c6cbcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59dde7662180cc01e4d16df105c6cbcd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stopped</b></td></tr>
<tr class="separator:a59dde7662180cc01e4d16df105c6cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6004d6879bf16324afad772ba53c844"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6004d6879bf16324afad772ba53c844"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><b>m_hEventStopping</b></td></tr>
<tr class="separator:aa6004d6879bf16324afad772ba53c844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1714355566db056095b56fbb5d3fd70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1714355566db056095b56fbb5d3fd70"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><b>m_hEventStopped</b></td></tr>
<tr class="separator:ac1714355566db056095b56fbb5d3fd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431d80fbcdc26a1f37656560b36c4422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a431d80fbcdc26a1f37656560b36c4422"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a431d80fbcdc26a1f37656560b36c4422">m_maxWorkerThreadCount</a></td></tr>
<tr class="memdesc:a431d80fbcdc26a1f37656560b36c4422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed number of threads. <br/></td></tr>
<tr class="separator:a431d80fbcdc26a1f37656560b36c4422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aecca9a9980cb68f2548a3155f0a517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aecca9a9980cb68f2548a3155f0a517"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#a1aecca9a9980cb68f2548a3155f0a517">m_streamIndex</a></td></tr>
<tr class="memdesc:a1aecca9a9980cb68f2548a3155f0a517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a next to check stream. <br/></td></tr>
<tr class="separator:a1aecca9a9980cb68f2548a3155f0a517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4374265c0516e89a8295fee879ad18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace4374265c0516e89a8295fee879ad18"></a>
TStreamsBusy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ace4374265c0516e89a8295fee879ad18">m_streamsBusy</a></td></tr>
<tr class="memdesc:ace4374265c0516e89a8295fee879ad18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy flags for each stream, true indicates that this stream is being read, thus cannot be read by another worker thread. <br/></td></tr>
<tr class="separator:ace4374265c0516e89a8295fee879ad18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be79f64cd765ea49b3fd958bb2d8f53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2be79f64cd765ea49b3fd958bb2d8f53"></a>
THandles&#160;</td><td class="memItemRight" valign="bottom"><b>m_workerThreads</b></td></tr>
<tr class="separator:a2be79f64cd765ea49b3fd958bb2d8f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b8dc5fb5e1415748bf04fb07b846bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56b8dc5fb5e1415748bf04fb07b846bc"></a>
TStreams&#160;</td><td class="memItemRight" valign="bottom"><b>m_streams</b></td></tr>
<tr class="separator:a56b8dc5fb5e1415748bf04fb07b846bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32a4e98270f89824ca2feaf895f2fb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad32a4e98270f89824ca2feaf895f2fb4"></a>
TStreamDelegates&#160;</td><td class="memItemRight" valign="bottom"><b>m_streamDelegates</b></td></tr>
<tr class="separator:ad32a4e98270f89824ca2feaf895f2fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad149cc6da158566cb545bd464255609a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad149cc6da158566cb545bd464255609a"></a>
enum net::StreamListener:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html#ad149cc6da158566cb545bd464255609a">m_state</a></td></tr>
<tr class="memdesc:ad149cc6da158566cb545bd464255609a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> internal state. <br/></td></tr>
<tr class="separator:ad149cc6da158566cb545bd464255609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ab51ce77fca9cd156e3098f6da6747d66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab51ce77fca9cd156e3098f6da6747d66"></a>
static <a class="el" href="a00032.html">util::ThreadMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>s_sync</b></td></tr>
<tr class="separator:ab51ce77fca9cd156e3098f6da6747d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81cebd289e4b0a5a9a60a80518953cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac81cebd289e4b0a5a9a60a80518953cf"></a>
static std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00026.html">StreamListener</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>s_instance</b></td></tr>
<tr class="separator:ac81cebd289e4b0a5a9a60a80518953cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Singleton reactor/dispatcher. </p>
<p>Global listener of stream incoming data. </p>

<p>Definition at line <a class="el" href="a00059_source.html#l00034">34</a> of file <a class="el" href="a00059_source.html">StreamListener.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a82c578c5e3aab1aa1437e4418b883e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::cancelRun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this method to request <a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d" title="Runs listening loop. ">run()</a> to stop listening to events. </p>
<p>This method is non-blocking and can be used from within the <a class="el" href="a00012.html" title="Base interface for stream event delegates. ">IStreamListenerDelegate</a>'s methods. Call <a class="el" href="a00026.html#ae356d8d7aa78dbfc05c7e6c4b2c2caca" title="Waits for the stop request to complete. ">joinRun()</a> to wait for <a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d" title="Runs listening loop. ">run()</a> to complete (but not from <a class="el" href="a00012.html" title="Base interface for stream event delegates. ">IStreamListenerDelegate</a>'s methods). </p>

<p>Definition at line <a class="el" href="a00057_source.html#l00145">145</a> of file <a class="el" href="a00057_source.html">StreamListener.cpp</a>.</p>

<p>References <a class="el" href="a00026.html#a292a818a35e3df4fae19cd805926197d">m_state</a>.</p>

</div>
</div>
<a class="anchor" id="a82c578c5e3aab1aa1437e4418b883e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::cancelRun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this method to request <a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d" title="Runs listening loop. ">run()</a> to stop listening to events. </p>
<p>This method is non-blocking and can be used from within the <a class="el" href="a00012.html" title="Base interface for stream event delegates. ">IStreamListenerDelegate</a>'s methods. Call <a class="el" href="a00026.html#ae356d8d7aa78dbfc05c7e6c4b2c2caca" title="Waits for the stop request to complete. ">joinRun()</a> to wait for <a class="el" href="a00026.html#a81f3ada1fcc33d43ff7ce3a34a6c5d0d" title="Runs listening loop. ">run()</a> to complete (but not from <a class="el" href="a00012.html" title="Base interface for stream event delegates. ">IStreamListenerDelegate</a>'s methods). </p>

</div>
</div>
<a class="anchor" id="a4ae654311b6c5bbe94a423047f28a122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">TStreamPtr</a> net::StreamListener::getNextStream </td>
          <td>(</td>
          <td class="paramtype">TDelegates &amp;&#160;</td>
          <td class="paramname"><em>delegates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>indexReset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be executed under a lock. </p>
<p>Gets next stream (as identified by m_strewamIndex) in a round-robin fashion. Returns NULL pointer if no streams available. </p>

<p>Definition at line <a class="el" href="a00057_source.html#l00252">252</a> of file <a class="el" href="a00057_source.html">StreamListener.cpp</a>.</p>

<p>References <a class="el" href="a00057_source.html#l00327">getStreamById()</a>, <a class="el" href="a00059_source.html#l00101">m_streamIndex</a>, and <a class="el" href="a00059_source.html#l00113">m_streamsBusy</a>.</p>

<p>Referenced by <a class="el" href="a00057_source.html#l00341">listenStreams()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00026_a4ae654311b6c5bbe94a423047f28a122_cgraph.gif" border="0" usemap="#a00026_a4ae654311b6c5bbe94a423047f28a122_cgraph" alt=""/></div>
<map name="a00026_a4ae654311b6c5bbe94a423047f28a122_cgraph" id="a00026_a4ae654311b6c5bbe94a423047f28a122_cgraph">
<area shape="rect" id="node2" href="a00026.html#aa8d6404f2beedb236dc1ded79df1e4ae" title="Must be executed under a lock. " alt="" coords="189,5,325,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4ae654311b6c5bbe94a423047f28a122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">TStreamPtr</a> net::StreamListener::getNextStream </td>
          <td>(</td>
          <td class="paramtype">TDelegates &amp;&#160;</td>
          <td class="paramname"><em>delegates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>indexReset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be executed under a lock. </p>
<p>Gets next stream (as identified by m_strewamIndex) in a round-robin fashion. Returns NULL pointer if no streams available. </p>

</div>
</div>
<a class="anchor" id="aa8d6404f2beedb236dc1ded79df1e4ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">TStreamPtr</a> net::StreamListener::getStreamById </td>
          <td>(</td>
          <td class="paramtype">::net::IStream::TId&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be executed under a lock. </p>
<p>Looks up a stream by its ID. </p>

<p>Definition at line <a class="el" href="a00057_source.html#l00327">327</a> of file <a class="el" href="a00057_source.html">StreamListener.cpp</a>.</p>

<p>Referenced by <a class="el" href="a00057_source.html#l00252">getNextStream()</a>, and <a class="el" href="a00057_source.html#l00419">writeStream()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8d6404f2beedb236dc1ded79df1e4ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">TStreamPtr</a> net::StreamListener::getStreamById </td>
          <td>(</td>
          <td class="paramtype">::net::IStream::TId&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be executed under a lock. </p>
<p>Looks up a stream by its ID. </p>

</div>
</div>
<a class="anchor" id="ae356d8d7aa78dbfc05c7e6c4b2c2caca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::joinRun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the stop request to complete. </p>
<p>Do not call this method from within of any <a class="el" href="a00012.html" title="Base interface for stream event delegates. ">IStreamListenerDelegate</a>'s methods, it will cause a deadlock. </p>

</div>
</div>
<a class="anchor" id="ae356d8d7aa78dbfc05c7e6c4b2c2caca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::joinRun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the stop request to complete. </p>
<p>Do not call this method from within of any <a class="el" href="a00012.html" title="Base interface for stream event delegates. ">IStreamListenerDelegate</a>'s methods, it will cause a deadlock. </p>

<p>Definition at line <a class="el" href="a00057_source.html#l00158">158</a> of file <a class="el" href="a00057_source.html">StreamListener.cpp</a>.</p>

<p>References <a class="el" href="a00026.html#a292a818a35e3df4fae19cd805926197d">m_state</a>.</p>

</div>
</div>
<a class="anchor" id="a81f3ada1fcc33d43ff7ce3a34a6c5d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs listening loop. </p>
<p>Call to this function blocks until stop (from some other thread or from within a delegate) is called. </p>

</div>
</div>
<a class="anchor" id="a81f3ada1fcc33d43ff7ce3a34a6c5d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs listening loop. </p>
<p>Call to this function blocks until stop (from some other thread or from within a delegate) is called. </p>

<p>Definition at line <a class="el" href="a00057_source.html#l00185">185</a> of file <a class="el" href="a00057_source.html">StreamListener.cpp</a>.</p>

<p>References <a class="el" href="a00026.html#a292a818a35e3df4fae19cd805926197d">m_state</a>, <a class="el" href="a00059_source.html#l00101">m_streamIndex</a>, <a class="el" href="a00059_source.html#l00113">m_streamsBusy</a>, and <a class="el" href="a00012.html#abe165b14106fc4dbcfa7e2ea259f8716">net::IStreamListenerDelegate::onStreamDied()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00026_a81f3ada1fcc33d43ff7ce3a34a6c5d0d_cgraph.gif" border="0" usemap="#a00026_a81f3ada1fcc33d43ff7ce3a34a6c5d0d_cgraph" alt=""/></div>
<map name="a00026_a81f3ada1fcc33d43ff7ce3a34a6c5d0d_cgraph" id="a00026_a81f3ada1fcc33d43ff7ce3a34a6c5d0d_cgraph">
<area shape="rect" id="node2" href="a00012.html#abe165b14106fc4dbcfa7e2ea259f8716" title="Is called when a stream has died. " alt="" coords="217,5,407,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0c110f176068877f399ac021befa1d5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::streamDied </td>
          <td>(</td>
          <td class="paramtype">::net::IStream::TId&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>errorDescription</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must NOT be executed under a lock. </p>
<p>Acquires a lock itself. Notifies all delegates of a stream error and removes the stream from a list of listened streams. </p>

<p>Definition at line <a class="el" href="a00057_source.html#l00448">448</a> of file <a class="el" href="a00057_source.html">StreamListener.cpp</a>.</p>

<p>References <a class="el" href="a00012.html#abe165b14106fc4dbcfa7e2ea259f8716">net::IStreamListenerDelegate::onStreamDied()</a>.</p>

<p>Referenced by <a class="el" href="a00057_source.html#l00442">closeStream()</a>, <a class="el" href="a00057_source.html#l00341">listenStreams()</a>, and <a class="el" href="a00057_source.html#l00419">writeStream()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00026_a0c110f176068877f399ac021befa1d5a_cgraph.gif" border="0" usemap="#a00026_a0c110f176068877f399ac021befa1d5a_cgraph" alt=""/></div>
<map name="a00026_a0c110f176068877f399ac021befa1d5a_cgraph" id="a00026_a0c110f176068877f399ac021befa1d5a_cgraph">
<area shape="rect" id="node2" href="a00012.html#abe165b14106fc4dbcfa7e2ea259f8716" title="Is called when a stream has died. " alt="" coords="190,5,381,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0c110f176068877f399ac021befa1d5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::streamDied </td>
          <td>(</td>
          <td class="paramtype">::net::IStream::TId&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>errorDescription</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must NOT be executed under a lock. </p>
<p>Acquires a lock itself. Notifies all delegates of a stream error and removes the stream from a list of listened streams. </p>

</div>
</div>
<a class="anchor" id="ada9bb428df95eec9c06e188352d59fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::writeStream </td>
          <td>(</td>
          <td class="paramtype">::net::IStream::TId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method should be used when writing to watched stream instead of <a class="el" href="a00011.html#aed1f4676e9d6d11b65df0b0a4afa40e9" title="Implementation is expected to write() to a stream synchroniosly, but this is not mandatory. ">IStream::write()</a> in order to let the <a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> instance handle stream errors. </p>
<p>This call is blocking. </p>

</div>
</div>
<a class="anchor" id="ada9bb428df95eec9c06e188352d59fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net::StreamListener::writeStream </td>
          <td>(</td>
          <td class="paramtype">::net::IStream::TId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method should be used when writing to watched stream instead of <a class="el" href="a00011.html#aed1f4676e9d6d11b65df0b0a4afa40e9" title="Implementation is expected to write() to a stream synchroniosly, but this is not mandatory. ">IStream::write()</a> in order to let the <a class="el" href="a00026.html" title="Singleton reactor/dispatcher. ">StreamListener</a> instance handle stream errors. </p>
<p>This call is blocking. </p>

<p>Definition at line <a class="el" href="a00057_source.html#l00419">419</a> of file <a class="el" href="a00057_source.html">StreamListener.cpp</a>.</p>

<p>References <a class="el" href="a00057_source.html#l00327">getStreamById()</a>, and <a class="el" href="a00057_source.html#l00448">streamDied()</a>.</p>

<p>Referenced by <a class="el" href="a00043_source.html#l00348">msg::Messenger::sendMessage()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00026_ada9bb428df95eec9c06e188352d59fd8_cgraph.gif" border="0" usemap="#a00026_ada9bb428df95eec9c06e188352d59fd8_cgraph" alt=""/></div>
<map name="a00026_ada9bb428df95eec9c06e188352d59fd8_cgraph" id="a00026_ada9bb428df95eec9c06e188352d59fd8_cgraph">
<area shape="rect" id="node2" href="a00026.html#aa8d6404f2beedb236dc1ded79df1e4ae" title="Must be executed under a lock. " alt="" coords="189,5,325,46"/><area shape="rect" id="node3" href="a00026.html#a0c110f176068877f399ac021befa1d5a" title="Must NOT be executed under a lock. " alt="" coords="189,70,325,111"/><area shape="rect" id="node4" href="a00012.html#abe165b14106fc4dbcfa7e2ea259f8716" title="Is called when a stream has died. " alt="" coords="374,70,565,111"/></map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sample/net/<a class="el" href="a00059_source.html">StreamListener.hpp</a></li>
<li>net/<a class="el" href="a00057_source.html">StreamListener.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 19 2014 17:19:59 for netcomm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
