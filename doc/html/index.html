<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>netcomm: The mainpage documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">netcomm
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The mainpage documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt></dt><dd><h1>Netcomm library</h1>
</dd></dl>
<h2>Overview</h2>
<p>This library is a C++ layer built above Windows Sockets (TCP sockets particularly), but Windows Sockets is not the only transport layer that can be utilized for data transmission. Other implementations (based say on UDP) can be provided.</p>
<p>Moreover above the simple transport layer, which provides abstracted streaming of data, a messenger service is implemented which provides generalized messaging functionality.</p>
<p>Finally several specialized messages are implemented and a service for sending/receiving these messages.</p>
<h2>Terminology</h2>
<ul>
<li>
<p class="startli"></p>
<p>Address &ndash; common address string shared between connecting parties</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Binding &ndash; can be server binding or client binding. Correspondingly it is a server listening on an address or a client connecting to this address.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Stream &ndash; Transmission of low level data as basic as bytes. Streams do not have any predefined length, but streams are reliable as TCP connections which means UDP-based stream implementation should implement some internal ordering of packets.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Message &ndash; messages are similar to streams and are built on top of streams except that they do have predefined length and type. Messages of a similar type are not obligated to have similar size, each message can have its own size, but the size and type are known before a message is transmitted.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Endpoint &ndash; some high level abstraction of a peer. Not really a part of a shared library, rather a particular implementation used in the <em>svc</em> component.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Delegate &ndash; used in source code as an alias for event sinks. Basically an interface implementation assigned to a corresponding object in order to listen for events from this objects.</p>
<p class="endli"></p>
</li>
</ul>
<h2>Source Code</h2>
<p>Source code is a Visual Studio 2008 solution which contains several projects:</p>
<ul>
<li>
<p class="startli"></p>
<p><em>interfaces</em><span style="font-style: normal"> &ndash; a collection of interfaces that need to be implemented in order to extend the library, there are also some delegates in </span><em>net</em><span style="font-style: normal"> and </span><em>msg</em><span style="font-style: normal"> projects. Probably they should be moved here, but they are tightly coupled with objects they service for, thus are defined in corresponding projects.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>net</em><span style="font-style: normal"> &ndash; implementation of the </span><em>net</em><span style="font-style: normal"> component</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>msg</em><span style="font-style: normal"> &ndash; implementation of the </span><em>msg</em><span style="font-style: normal"> components</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>svc</em><span style="font-style: normal"> &ndash; sample service utilizing </span><em>net</em><span style="font-style: normal"> and </span><em>msg</em><span style="font-style: normal"> components</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>client</em><span style="font-style: normal"> &ndash; client utilizing the service</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>server</em><span style="font-style: normal"> &ndash; server utilizing the service</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>util</em><span style="font-style: normal"> &ndash; collection of utility classes, most of them should be substituted for more efficient implementations like </span><em>boost::shared_ptr</em><span style="font-style: normal">, or </span><em>boost::scoped_array</em><span style="font-style: normal">. Also </span><em>ThreadMutex</em><span style="font-style: normal"> and </span><em>ScopedLock</em><span style="font-style: normal"> are good candidates for substitution by </span><em>ACE</em><span style="font-style: normal">, </span><em>boost</em><span style="font-style: normal"> or even </span><em>MFC </em><span style="font-style: normal">classes.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>netcomm</em><span style="font-style: normal"> &ndash; unit tests for the library</span></p>
<p class="endli"></p>
</li>
</ul>
<h2>Components</h2>
<p>There are three main components:</p>
<ul>
<li>
<p class="startli"></p>
<p><em>net</em> &ndash; implementation of raw data streaming</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>msg</em> &ndash; messaging service</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>svc</em> &ndash; an application-specific service utilizing functionality of the <em>net</em> and <em>msg</em> components</p>
<p class="endli"></p>
</li>
</ul>
<p>Each is built a top of a previous one.</p>
<h3>net</h3>
<p>Main interfaces:</p>
<ul>
<li>
<p class="startli"></p>
<p><em>IBinding</em> &ndash; Two implementation must be provided: for server and for the client binding. Server implementation in its <em>bind()</em><span style="font-style: normal"> implementation must listen for incoming connections and actually provide some acceptor-connector pattern implementation. Client implementation must connect to the address provided. Both implementations must create </span><em>IStream</em><span style="font-style: normal"> instance and notify of its creation to an </span><em>IBindingDelegate</em><span style="font-style: normal"> provided. After a binding is established and a stream is created there's no difference between server and client side. All library's functionality disregards server vs client difference.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>IBindingDelegate</em><span style="font-style: normal"> &ndash; this interface must be implemented by a class listening for new connections. Once a connection is established (after server and client </span><em>IBinding</em><span style="font-style: normal"> implementations successfully </span><em>bind() </em><span style="font-style: normal">to the same address), a method of this interface are called to notify the listening party of the new connection. This is the best place to put a newly created stream under </span><em>StreamListener</em><span style="font-style: normal">'s control (see further).</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>IStream &ndash;</em><span style="font-style: normal"> implementation is responsible for sending and receiving bytes over an established connection. The receiving part is non-blocking so if no data are available implementation must not wait for incoming data, rather should return zero. Note, this differs from semantics of Windows Socket's </span><em>recv</em><span style="font-style: normal"> function.</span></p>
<p class="endli"></p>
</li>
</ul>
<p>Main classes:</p>
<ul>
<li>
<p class="startli"></p>
<p><em>TcpServer</em> &ndash; server-side implementation of <span style="font-style: normal">the </span><em>IBinding</em><span style="font-style: normal"> interface.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>TcpClient</em><span style="font-style: normal"> &ndash; client-side implementation of the </span><em>IBinding</em><span style="font-style: normal"> interface.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>TcpStream</em><span style="font-style: normal"> &ndash; implements </span><em>IStream</em><span style="font-style: normal"> data sendning and receiving methods over a TCP connection.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>BindingFactory</em><span style="font-style: normal"> &ndash; factory class to create bindings. Since only TCP connection is utilized this factory is not really required for this implementation, but can be required if a library is extended, say, the way that bindings are established above bindings of other types. Or in case dynamic binding type is determined at runtime (e.g. a user chooses between a TCP binding or some other custom binding).</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em><span style="text-decoration: none"><span style="font-weight: normal">IStreamListenerDelegate</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"></p>
<ul>
<li><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> event handler</span></span></span></li>
</ul>
<p></span></span></span></p>
<p class="endli"><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
</li>
<li>
<p class="startli"><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em>StreamListener</em><span style="font-style: normal"> &ndash; very important class. Despite of the long description provided below its usage is pretty straitforward. If there's a stream and a class interested in receiving events about this stream, the class must implement </span><em><span style="text-decoration: none"><span style="font-weight: normal">IStreamListenerDelegate</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> and register itself with a corresponding stream within </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">. Once registered, use </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener::writeStream()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> method instead of direct </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">Istream::write()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">. But devil is in details, thus detail follow.</span></span></span></span></span></span></p>
<p class="endli"><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
</li>
</ul>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<h3>StreamListener</h3>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em>StreamListener</em><span style="font-style: normal"> is not intended to be sub-classed. Rather it is a class that listens for registered streams and reacts to incoming data by firing events to registered delegates. It is a singleton, which means there's only one instance of this class for a module (exe or dll).</span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal">It is a handy class to avoid going into a manual data listening loop both on server and client side. </span><em><span style="text-decoration: none">StreamListener</span></em><span style="font-style: normal"><span style="text-decoration: none"> utilizes several threads to listen for incoming data. Number of threads is limited to number of processors (cores) on a system. Threads access streams in round-robin fashion by checking streams one by one and if data are available for some stream these data are pulled from that stream and an event is fired to a corresponding delegate.</span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em><span style="text-decoration: none"><b>Error handling with StreamListener</b></span></em></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal"><span style="text-decoration: none">There are constraints on stream usage imposed by possible errors and appropriate handling of these errors in regards to </span></span><em><span style="text-decoration: none">StreamListener</span></em><span style="font-style: normal"><span style="text-decoration: none">. Since errors can encounter while receiving data, </span></span><em><span style="text-decoration: none">StreamListener</span></em><span style="font-style: normal"><span style="text-decoration: none"> is also responsible for notifying delegates about stream's death. If a stream is disconnected an event is fired to the same delegate listening for incoming data events. Since stream's death can be detected not only during data receiving but also while sending data, </span></span><em><span style="text-decoration: none">StreamListener</span></em><span style="font-style: normal"><span style="text-decoration: none"> provides a special method for writing to a stream </span></span><em><span style="text-decoration: none">writeStream()</span></em><span style="font-style: normal"><span style="text-decoration: none"> which allows </span></span><em><span style="text-decoration: none">StreamListener</span></em><span style="font-style: normal"><span style="text-decoration: none"> to be aware of stream's death and be able to notify the same delegate. Thus any streams registered within </span></span><em><span style="text-decoration: none">StreamListener</span></em><span style="font-style: normal"><span style="text-decoration: none"> must send data by </span></span><em><span style="text-decoration: none">StreamListener::writeStream()</span></em><span style="font-style: normal"><span style="text-decoration: none"> method.</span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em><span style="text-decoration: none"><b>Registration of delegates</b></span></em></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">Delegates for stream events must implement </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">IStreamListenerDelegate</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> interface methods. A delegate interested in event for a particular stream calls </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener::addDelegate()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> method which 1) registers a stream within </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">,</span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">2) registers a delegate listening for events for the specified stream.</span></span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">Streams and delegates can be registered within </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener:</span></span></em></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<ul>
<li>
<p class="startli"></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">before </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener::run()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> is called</span></span></span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">after it has stopped running</span></span></span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">while it is running</span></span></span></p>
<p class="endli"></p>
</li>
</ul>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">but cannot be registered between </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">cancelRun()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> is called and before </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">run()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> has completed execution. Basically since all delegates are unregistered and streams are destroyed when </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> stops, there's no point in adding new delegates at this moment.</span></span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em><span style="text-decoration: none"><b>StreamListener delegates lifetime</b></span></em></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em><span style="text-decoration: none"><span style="font-weight: normal">IStreamListenerDelegate</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> implementations must be alive all the time they are a subject to event notification. All events to delegates are fired while </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> is running thus delegates must be alive until </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener::run()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> stops execution. </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener::writeStream()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> can also detect stream's death but all delegates are unregistered after </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> is stopped, thus there's no one to notify about stream's death. So if </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> is stopped, do not send data through it. But it is OK to send data after </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> has a delegate registered for the corresponding stream.</span></span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> starts listening for incoming data when its </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">run()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> method is called. This method is blocking, it does not exit until </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> stops all threads listening for incoming data. In order to stop listening </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">cancelRun()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> method should be called. Obviously from some other thread, say from one of the delegate event handlers or from a UI thread if </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">run()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> is not executed on the UI thread (otherwise it would be a bad idea since a UI thread would be blocked).</span></span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em><span style="text-decoration: none"><span style="font-weight: normal">cancelRun()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> notifies </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> that it should be stopped, but it might take time to stop. In order to wait for </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> to actually stop </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">joinRun()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> method should be called. It blocks until </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> is stopped. Grounding for such separation is that a decision that </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> should stop can be made withing of </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">IStreamListenerDelegate</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> methods, thus </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">cancelRun()</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> could be called from within delegate's method which in turn is executed from the </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">. Thus if </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> waits for a delegate's method to finish, while the method is waiting for the </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> to stop, it causes a deadlock straight away.</span></span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<h2>Binding lifetime</h2>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">Streams are not owned by bindings, streams are owned and their lifetime is managed by </span></span></span><em><span style="text-decoration: none"><span style="font-weight: normal">StreamListener.</span></span></em><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> Bindings are also not owned by streams. This design decision is questionable, probably streams should own their bindings, but currently they don't. If a binding is destroyed a stream dies. Thus a client and a server must keep corresponding bindings alive until a stream dies.</span></span></span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<h3>msg</h3>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">Main interfaces:</span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<ul>
<li>
<p class="startli"></p>
<p>IMessage &ndash; implementation of a message. Every message has a type. Every implementation must be able to serialize its data into a stream and to deserialize its data from a stream.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>IBindingDelegate</em> &ndash; handles stream creation event. Despite it is named the same way as an interface in the <em>net</em><span style="font-style: normal"> component, and is in fact to be implemented to handle the same stream creation event, it differs in its semantics because implementation is not required to put created stream under </span><em>StreamListener</em><span style="font-style: normal">'s control, rather it is a good place to register </span><em>ImessengerDelegate</em><span style="font-style: normal">-s for a newly created streams.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>IMessengerDelegate</em><span style="font-style: normal"> &ndash; similar to </span><em>IStreamListenerDelegate</em><span style="font-style: normal"> in regards to semantics of events received, but it instead of row data it receives notifications of high-level events.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em>IMessageFactory</em><span style="font-style: normal"> &ndash; implementation of this interface must be provided in order to create messages by their types.</span></p>
<p class="endli"></p>
</li>
</ul>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">Main classes:</span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<ul>
<li>
<p class="startli"></p>
<p><em>Messenger</em><span style="font-style: normal"> &ndash; supplied with a </span><em>IMessageFactory</em><span style="font-style: normal"> implementation and a </span><em>IBindingDelegate</em><span style="font-style: normal"> implementation it handles messages transmitted over the streams and notifies registered delegates.</span></p>
<p class="endli"></p>
</li>
</ul>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><em>Messenger</em><span style="font-style: normal"> is similar to </span><em>StreamListener</em><span style="font-style: normal">, but unlike the latter it works with messages as opposed to raw stream data. Messages are high-level abstractions of application specific data sent over network.</span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal">When sending messages over streams </span><em>Messenger</em><span style="font-style: normal"> uses a message header which is 8 bytes long. First 4 bytes are reserved for message type, second 4 bytes &ndash; are for message payload length. Thus message payload length cannot exceed 4Gb.</span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<h3>svc</h3>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal">Actually this is a sample implementation of interfaces described above and utilization of <em>StreamListener</em><span style="font-style: normal"> and </span><em>Messenger</em><span style="font-style: normal"> classes.</span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal">Main interfaces:</span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<ul>
<li>
<p class="startli"></p>
<p><em>IserviceDelegate</em><span style="font-style: normal"> &ndash; client and server implement this interface to get notifications about newly connected endpoints or disconnected endpoints and also directory listing responses.</span></p>
<p class="endli"></p>
</li>
</ul>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><span style="font-style: normal">Main classes:</span></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </p>
<ul>
<li>
<p class="startli"></p>
<p><em><a class="el" href="a00027.html">SvcMsgFactory</a></em><span style="font-style: normal"> &ndash; message factory for service-specific messages (</span><em>IMessageFactory </em><span style="font-style: normal">implementation). Creates messages supported by the service.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em><a class="el" href="a00015.html" title="Message &#39;endpoint identity&#39;. ">MessageIdentity</a></em><span style="font-style: normal"> &ndash; a message that is sent when a connection is established. It contains endpoint id. The message is sent to notify the other connection party about endpoint identity.</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em><a class="el" href="a00016.html" title="Message &#39;request dir contents&#39;. ">MessageRequestDir</a></em><span style="font-style: normal"> &ndash; a message that is sent to an endpoint to request a directory contents</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em><a class="el" href="a00017.html" title="Message &#39;response with dir contents&#39;. ">MessageResponseDir</a></em><span style="font-style: normal"> &ndash; a response message that contains a listing of files in a directory</span></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><em><a class="el" href="a00021.html" title="Service sending/receiving messages. ">Service</a></em><span style="font-style: normal"> &ndash; this class should be made a singleton in a real world scenario, but for simplicity is left as is. It provides even higher level of abstraction by providing specialized methods and notifications for asynchronous directory listing requests. This class utilizes the full stack including bindings, </span><em>StreamListener</em><span style="font-style: normal"> and </span><em>Messenger</em><span style="font-style: normal"> and can be used as an example of application service implementations.</span></p>
<p class="endli"></p>
</li>
</ul>
<p></span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"><br/>
<br/>
 </span></span></span></p>
<p><span style="font-style: normal"><span style="text-decoration: none"><span style="font-weight: normal"> </span></span></span></p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 19 2014 17:20:00 for netcomm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
